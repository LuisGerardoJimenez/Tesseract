\chapter{Marco teórico} \label{cap:dos}

Todo proyecto de software se desencadena por alguna necesidad de negocios: la de corregir un defecto en una aplicación existente, la de adaptar un “sistema heredado” a un ambiente de negocios cambiante, la de ampliar las funciones y características de una aplicación ya existente o la necesidad de crear un producto, servicio o sistema nuevo.

\section{Ingeniería de software}

Una de las primeras definiciones de ingeniería de software fue dada por Fritz Bauer en el año de 1969, quien define que la ingeniería de software es..\\

	\textit {“el establecimiento y uso de principios robustos, orientados a obtener software económico que sea fiable y que funcione de manera eficiente sobre máquinas reales” }. \hyperlink{b09}{[9]}\\
	
  Aunque esta definición omite algunos términos referentes a tiempos de entrega, procesos eficaces, y calidad de software, nos da un panorama de sus principios fundamentales y es también la base de la definición que la IEEE ha desarrollado de una manera más completa: \\

 \textit {"La ingeniería de software es: La aplicación de un enfoque sistemático, disciplinado y cuantificable al desarrollo, operación y mantenimiento de software; es decir, la aplicación de la ingeniería al software.”}  \hyperlink{b09}{[9]}\\

La ingeniería de software está formada por un proceso, un conjunto de métodos (prácticas) y un arreglo de herramientas que permite a los profesionales elaborar software de cómputo de alta calidad. 

Un aspecto muy importante de Ingeniería de Software es que proporciona parámetros formales para lo que se conoce como Gestión (o Administración) de Proyectos de Software. Esto se refiere a que Ingeniería de Software proporciona diversas métricas y metodologías que pueden usarse como especificaciones para todo lo referente a la administración del personal involucrado en proyectos de software, ciclos de vida de un proyecto de software, costos de un proyecto, y en si todo el aspecto administrativo que
implica el desarrollar software.\\

La ingeniería en general es el análisis, diseño, construcción, verificación y gestión de entidades técnicas. En general, todo proceso de ingeniería debe comenzar por contestar las siguientes preguntas: ¿Cuál es el problema a
resolver?, ¿Cuáles son las características de la entidad que se utiliza para resolver el problema?, ¿Cómo se realizará la entidad (y la solución)?, ¿Cómo se construirá la entidad?, ¿Cómo va a probarse la entidad?, y ¿Cómo se apoyará la entidad cuando los
usuarios finales soliciten correcciones y adaptaciones a la entidad?.  \hyperlink{b09}{[9]}  \\

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=.95\textwidth]{images/CapasIS}
		\caption{Capas de la ingeniería de software}
		\label{fig:capas_is}
	\end{center}
\end{figure}

La ingeniería de software es una tecnología con varias capas, como se muestra en la figura 2.1, existen 4 capas: herramientas, métodos, procesos y compromiso con la calidad. Cada una de ellas es importante, sin embargo, la capa de proceso es fundamental para el desarrollo de software, ya que es donde se define la estructura básica del producto hasta la culminación del mismo.

El proceso de software forma la base para el control de la administración de proyectos de software, y establece el contexto en el que se aplican métodos técnicos, se generan productos del trabajo (modelos, documentos, datos, reportes, formatos, etc.), se establecen puntos de referencia, se asegura la calidad y se administra el cambio de manera apropiada.\hyperlink{b09}{[9]} 

\section{Proceso de desarrollo de software}

Se define proceso del software como una estructura para las actividades, acciones y tareas que se requieren a fin de construir software de alta calidad. La ingeniería de software es llevada a cabo por personas creativas y preparadas que deben adaptar un proceso maduro de software a fin de que resulte apropiado para los productos que construyen y para las demandas de su mercado.
Cuando se trabaja en la construcción de un producto o sistema, es importante ejecutar una serie de pasos predecibles, una estructura general para la ingeniería de software se define en cinco actividades elementales: \hyperlink{b09}{[9]} 

\begin{enumerate}
	\item Comunicación
	\item Planeación
	\item Modelado
	\item Construcción
	\item Despliegue
\end{enumerate}

Existen diferentes metodologías de desarrollo con modificaciones y adecuaciones al esquema general de construcción antes mencionado, algunas de ellas son las metodologías tradicionales y ágiles. Este proceso puede tener diferentes variaciones, sin embargo, sea cual sea la metodología aplicada, las etapas de Modelado (Análisis y Diseño) y Costrucción (Codificación y Pruebas) son las más críticas e importantes para un producto final exitoso.

Durante el desarrollo, se realizan tareas específicas para cada etapa, por ejemplo, para la etapa de modelado se elabora el documento de análisis (donde se describe el funcionamiento del sistema), así como el diseño (en donde se genrean los diagramas que describen el funcionamiento establecido en el análisis); en la fase de construcción se genera el código del software y en la etapa de pruebas se valida y verifica que el software cumpla con lo asentado en las fases precedentes.

\subsection{Análisis}

El proceso de análisis dentro del desarrollo de software consiste en obtener los requerimientos del sistema para crear una solución, identificar los problemas a resolver o necesidad a ser atendida, evaluar las restricciones que presenta, así como los insumos se requieren para su debida construcción.
Al ser la primera etapa dentro del proceso de desarrollo es las más crítica y sensible, ya que cualquier error de gran impacto que surja dentro de esta perjudicará las etapas consecuentes ocasionando retrasos en el proceso.\hyperlink{b09}{[9]} 

\bigskip

En esta etapa se construye el documento de análisis, en donde se describen todos los requerimientos que el cliente ha solicitado mediante diferentes componentes
Con base en los requisitos, el analista sigue el proceso de análisis identificando en alto nivel que funcionalidades deberá poseer el sistema para cumplir los requerimientos. Una solución común para mapear cada funcionalidad es a través de CASOS DE USO.

Este documento emplea un lenguaje técnico especializado ya que busca ser comprendido por los diseñadores y programadores para su correcta construcción. \hyperlink{b09}{[9]} 

\subsubsection{Documento de análisis}

Parte 1. Modelo de negocio:
\begin{itemize}
	\item Glosario de términos.
	\item Modelo de información utilizado para representar la información que será almacenada en el sistema.
	\item Reglas de negocio mediante las cuales se normará el funcionamiento del sistema.
\end{itemize}

Parte 2. Modelo dinámico, el cual describe funcionalidad a partir de los siguientes capítulos:
\begin{itemize}
	\item Arquitectura lógica.
	\item Máquinas de estados que modelarán el comportamiento de las entidades que así lo necesiten.
	\item Funciones y roles que tendrán los actores que interactuarán con el sistema.
	\item Casos de uso que describen funcionalidad.
\end{itemize}

Parte 3. Interacción con el usuario, que muestra las interfaces y mensajes a partir de los siguientes capítulos:
\begin{itemize}
	\item Interfaces del sistema.
	\item Catálogo de mensajes.
\end{itemize}



\subsubsection{Caso de Uso}

Un caso de uso es una actividad que puede realizar un usuario dentro del software. Estas actividades sirven para describir el comportamiento del producto en distintas condiciones en las que el sistema responde a alguna de las peticiones realizadas por el usuario, es decir, describe el funcionamiento de los componentes acorde a las acciones que los usuarios realizan dentro del software.

En un libro que analiza cómo escribir casos de uso eficaces, Alistair Cockburn [Coc01b] afirma que “un caso de uso capta un contrato […] [que] describe el comportamiento del sistema en distintas condiciones en las que el sistema responde a una petición de alguno de sus participantes[…]”.

En esencia, un caso de uso narra una historia estilizada sobre cómo interactúa un usuario final (que tiene cierto número de roles posibles) con el sistema en circunstancias específicas. La historia puede ser un texto narrativo, un lineamiento de tareas o interacciones, una descripción basada en un formato o una representación diagramática. Sin importar su forma, un caso de uso ilustra el software o sistema desde el punto de vista del usuario final.

Un caso de uso está compuesto por distintos elementos, los cuales se describen a continuación:
\begin{itemize}
\item \textbf{Actor}: Es la idealización de un rol que puede jugar una persona, otro sistema, proceso, un dispositivo o de alguna cosa que interactúa con el sistema. Los actores son objetos que residen fuera del sistema, en tanto que los casos de uso están compuestos por objetos y acciones que residen dentro del sistema. Todo actor tiene uno o más objetivos cuando utiliza el sistema.  \hyperlink{b12}{[12]}. 

\item \textbf{Entidad} : Representación de un objeto exclusivo único en el mundo real que se está controlando. Algunos ejemplos de entidad son una sola persona, un solo producto o una sola organización. 

\item \textbf{Atributo} : Es una especificación que define una propiedad de un objeto, elemento o archivo. También puede referirse o establecer el valor específico para una instancia determinada de los mismos.

\item \textbf{Entrada}: Es la información producida por el usuario para ser guardada o procesada en el sistema. El usuario comunica y determina qué clases de entrada aceptará el sistema (por ejemplo, secuencias de control o de texto escritas a máquina a través del teclado y el ratón).

\item \textbf{Salida}: Es la información producida por el sistema y percibida por el usuario. Las clases de salida los productos de programa, y las clases de entrada la que el programa acepta, definen la interfaz de usuario del programa.

\item \textbf{Acción}: Evento originado por el usuario mediante botones.

\item \textbf{Pantalla}: Es la interfaz de usuario, utiliza imágenes, iconos y menús para mostrar las acciones disponibles entre las que el usuario puede escoger en un sistema. Su función es proporcionar un entorno visual amigable y sencillo de usar que facilite la comunicación del usuario con el software.

\item \textbf{Regla de Negocio}: Es aquella que rige los procesos de un negocio para garantizar el correcto funcionamiento del software. Las reglas de negocio establecen los procedimientos que se deben realizar y las condiciones sobre las que dichas actividades se van a ejecutar.

\item \textbf{Mensaje}: Constituyen la mínima unidad de comunicación entre el usuario y el sistema. Se trata de un proceso de comunicación completa porque el sistema lanza un mensaje hacia el usuario que no se resuelve hasta que el usuario lo recibe o lo responde, completando así el proceso de comunicación con la realimentación correspondiente.

\item \textbf{Trayectoria}: Es un conjunto de pasos que describen la interaccion entre el usuario y el sistema.

\item \textbf{Paso}: Es una instruccion que realiza el usuario o el sistema.

\item \textbf{Precondición}: Está formada por el conjunto de condiciones que se tienen que cumplir para que se pueda iniciar un caso de uso. En muchos casos supone la ejecución de casos de uso previos.

\item \textbf{Postcondición}: Refleja el estado en que se queda el sistema una vez ejecutado el caso de uso.

\item \textbf{Puntos de extensión}: Es la incorporación implícita del comportamiento de otro caso de uso, el cuál no es parte del flujo principal. Modela la parte opcional del sistema, un subflujo que sólo se ejecuta bajo ciertas condiciones o varios flujos que se pueden insertar en un punto determinado. 
\end{itemize}

\section{Herramienta CASE}

\subsection{Definición}

Las tecnologías de ingeniería de software asistida por computadora (CASE) son herramientas que brindan asistencia automatizada para el desarrollo de software . El objetivo de presentar las herramientas CASE es la reducción del tiempo y el costo del desarrollo de software y la mejora de la calidad de los sistemas desarrollados. \hyperlink{b15}{[15]} 

El interés en las herramientas y entornos de CASE se basa en las expectativas de:
\begin{itemize}
	\item Aumentar la productividad
	\item Mejorar la calidad del producto
	\item Facilitar el mantenimiento
	\item Hacer que la tarea de los ingenieros de software sea menos odiosa y más agradable. 
\end{itemize}

Una herramienta CASE se puede clasificar en tres categorías  :

\begin{itemize}
	\item Upper CASE (U-CASE), herramientas que ayudan en las fases de planificación, análisis de requisitos y estrategia del desarrollo, usando, entre otros diagramas UML.
	\item Middle CASE (M-CASE), herramientas para automatizar tareas en el análisis y diseño de la aplicación.
	\item Lower CASE (L-CASE), herramientas que semi-automatizan la generación de código, crean programas de detección de errores, soportan la depuración de programas y pruebas. Además automatizan la documentación completa de la aplicación. Aquí pueden incluirse las herramientas de desarrollo rápido de aplicaciones.
\end{itemize}

Debido a sus similitudes, a veces Upper CASE y Middle CASE simplemente se conocen como Upper CASE. En general, Upper CASE es una herramienta para una vista de alto nivel del desarrollo de software, mientras que lower CASE se utiliza principalmente como herramienta en la fase de programación y prueba. \hyperlink{b16}{[16]}

\section {Implementación del desarrollo}

\subsection{Patrones de diseño}

Cada patrón describe un problema que ocurre una y otra vez en nuestro entorno, también describe el núcleo de la solución a ese problema, de tal manera que puede usar esta solución un millón de veces, sin tener que hacerlo lo mismo dos veces. \hyperlink{b19}{[19]} \\

En general, un patrón tiene cuatro elementos esenciales \hyperlink{b17}{[17]}:

\begin{enumerate}
	\item El nombre del patrón es un identificador que podemos usar para describir un problema de diseño, sus soluciones y consecuencias en una o dos palabras. Nombrar un patrón nos permite diseñar a un nivel más alto de abstracción.
	
	\item El problema describe cuándo aplicar el patrón. Explica el problema y su contexto. Podría describir problemas de diseño específicos, como la forma de representar algoritmos como objetos. Podría describir estructuras de clase u objeto que son sintomáticas de un diseño inflexible. A veces, el problema incluirá una lista de condiciones que deben cumplirse antes de que tenga sentido aplicar el patrón.
	
	\item La solución describe los elementos que componen el diseño, sus relaciones, responsabilidades y colaboraciones. La solución no describe un diseño o implementación concreta en particular, porque un patrón es como una plantilla que se puede aplicar en muchas situaciones diferentes. En cambio, el patrón proporciona una descripción abstracta de un problema de diseño y cómo lo resuelve una disposición general de elementos (clases y objetos en nuestro caso).
	
	\item Las consecuencias son los resultados y las compensaciones de aplicar el patrón. Aunque las consecuencias a menudo no se expresan cuando describimos las decisiones de diseño, son críticas para evaluar las alternativas de diseño y para comprender los costos y beneficios de aplicar el patrón. Las consecuencias para el software a menudo se refieren a compensaciones de espacio y tiempo. También pueden abordar problemas de lenguaje e implementación. Dado que la reutilización es a menudo un factor en el diseño orientado a objetos, las consecuencias de un patrón incluyen su impacto en la flexibilidad de un sistema, extensibilidad o portabilidad. Enumerar estas consecuencias explícitamente le ayuda a comprenderlas y evaluarlas.
\end{enumerate}

\subsubsection{Patrón de Diseño MVC (Modelo Vista-Controlador)}

El patrón de diseño de modelo-vista-controlador (MVC) especifica que una aplicación consta de un modelo de datos, de información de presentación y de información de control. El patrón requiere que cada uno de estos elementos esté separado en distintos objetos. \hyperlink{b17}{[17]}

\subsubsection{Características}
MVC consta de tres tipos de objetos:
\begin{enumerate}
\item El modelo es el objeto de la aplicación (por ejemplo, la información de datos) contiene únicamente los datos puros de aplicación; no contiene lógica que describe cómo pueden presentarse los datos a un usuario.
\item La vista es su presentación en pantalla  (por ejemplo, la información de presentación) presenta al usuario los datos del modelo. La vista sabe cómo acceder a los datos del modelo, pero no sabe el significado de estos datos ni lo que el usuario puede hacer para manipularlos.
\item Por último, el controlador que  define la forma en que la interfaz de usuario reacciona a la entrada del usuario(por ejemplo, la información de control) está entre la vista y el modelo. Escucha los sucesos desencadenados por la vista (u otro origen externo) y ejecuta la reacción apropiada a estos sucesos. En la mayoría de los casos, la reacción es llamar a un método del modelo. Puesto que la vista y el modelo están conectados a través de un mecanismo de notificación, el resultado de esta acción se reflejará automáticamente en la vista.
\end{enumerate}

El comportamiento se ilustra en la figura 2.2\\
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=.65\textwidth]{images/marcoteorico/mvc}
		\caption{Imagen que ilustra el modelo Vista-Controlador}
		\label{fig:mvc}
	\end{center}
\end{figure}

MVC desacopla las vistas y los modelos al establecer un protocolo de suscripción / notificación entre ellos. Una vista debe garantizar que su apariencia refleje el estado del modelo. Cada vez que los datos del modelo cambian, el modelo notifica las vistas que dependen de él. En respuesta, cada vista tiene la oportunidad de actualizarse. Este enfoque le permite adjuntar múltiples vistas a un modelo para proporcionar diferentes presentaciones. También puede crear nuevas vistas para un modelo sin reescribirlo.\\

El siguiente diagrama muestra un modelo y tres vistas. (Se omitieron los controladores por simplicidad). El modelo contiene algunos valores de datos, y las vistas que definen una hoja de cálculo, un histograma y un gráfico circular muestran estos datos de varias maneras. El modelo se comunica con sus vistas cuando cambian sus valores, y las vistas se comunican con el modelo para acceder a estos valores. \hyperlink{b20}{[20]} 

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=.65\textwidth]{images/marcoteorico/mvc2}
		\caption{Imagen que ilustra un ejemplo de cómo opera el MVC }
		\label{fig:mvc2}
	\end{center}
\end{figure}


\subsection{Framework}

\subsubsection{Definición}
Es un conjunto de clases que encarna un diseño abstracto para soluciones a una familia relacionada de problemas. \hyperlink{b17}{[17]}. 

Conjunto de clases cooperativas que construyen un diseño reutilizable para un tipo específico de software. Un Framework proporciona la arquitectura partiendo el diseño en clases abstractas y definiendo sus responsabilidades y colaboraciones. Un desarrollador realiza una aplicación haciendo subclases y componiendo instancias a partir de las clases definidas por el Framework. \\

Un framework es una aplicación semi-completa, de control invertido, así un Framework difiere de una librería de clases \hyperlink{b17}{[17]}:
\begin{itemize}
	\item En una librería de clases, el control del flujo se encuentra en el código de la aplicación que realiza llamadas a los métodos de la librería de clases.
	\item En un framework, el control del flujo está en código del framework que realiza llamadas al código de la aplicación (control invertido).
\end{itemize}

\subsubsection {Ventajas de un framework}
Como ventajas en la utilización de un framework tenemos las siguientes:

\begin{enumerate}
	\item Minimiza tiempos de desarrollo / acorta el “Time to market”
	\begin{itemize}
	\item Los proyectos de desarrollo ya no tendrán que resolver los múltiples problemas asociados a las aplicaciones web.
	\item  Los frameworks reducen la codificación y sobretodo la puesta en marcha, ya que proporcionan subsistemas que sabemos que ya funcionan. \item  En definitiva, proporcionan código que no se tendrá que mantener ni reescribir.
	\end{itemize}
	\item Reduce los riesgos del desarrollo.
	\begin{itemize}
		\item Con un modelo de programación complejo como el de J2EE, el riesgo de fallos en los proyectos iniciales es alto.
	\end{itemize}
	\item Proporciona una arquitectura consistente entre aplicaciones.
	\begin{itemize}
		\item Al usar frameworks todas las aplicaciones generadas comparten una arquitectura común. Esto hace que sea más fácil de aprender, mantener y soportar.
		\item Cualquier programador que trabaje con un framework no deberá invertir gran parte de su tiempo en buscar las clases necesarias, interconectarlas o descubrir los métodos que contienen. Los frameworks ocultan toda esta complejidad dando un alto nivel de abstracción. 
	\end{itemize}
\end{enumerate}

\section{Pruebas}

Con base en los enunciados de la ISTQB (International Software Testing Qualifications Board). \hyperlink{b34}{[34]} Las pruebas de software muestran la presencia de defectos: todo tipo de software que se desarrolle es susceptible a la presencia de «Bug`s» o defectos, con el testing de software se busca reducir al máximo la presencia de estos, pero no se puede asegurar que el software esté libre de defectos, al contrario, con el tiempo las modificaciones o adiciones de funcionalidades aumenta el riesgo de la presencia de nuevos defectos.

Las pruebas dinámicas y estáticas son métodos complementarios, ya que tienden
para encontrar diferentes tipos de defectos de manera efectiva y eficiente. Tipos de defectos que son más fáciles de encontrar durante las pruebas estáticas son: desviaciones de los estándares, falta requisitos, defectos de diseño, código no mantenible e interfaz inconsistente especificaciones. Tenga en cuenta que, a diferencia de las pruebas dinámicas, las pruebas estáticas encuentran defectos en lugar de fallas.


\subsection{Pruebas Dinámicas}

La ISTQB (International Software Testing Qualifications Board) dice que la pruebas dinámicas son todas aquellas pruebas que para su realización requieren la ejecución de la aplicación. Con los métodos de prueba dinámicos, el software se ejecuta utilizando un conjunto de valores de entrada y su salida se examina y compara con lo que se espera.   Las pruebas dinámicas permiten el uso de técnicas de caja negra y caja blanca con mayor amplitud.\\

Dentro de las pruebas dinámicas podemos encontrar distintos niveles de prueba. Los niveles de prueba son grupos de actividades de prueba que se organizan y gestionan juntas. Cada nivel de prueba es una instancia del proceso de prueba, realizadas en relación con software en un determinado nivel de desarrollo, desde unidades individuales o componentes hasta sistemas completos o, en su caso, sistemas de sistemas.\\

Los niveles de prueba utilizados pueden ser:

\begin{itemize}
	\item Prueba de componentes.
	\item Pruebas de integración.
	\item Prueba de sistema.
	\item Pruebas de aceptación.
\end{itemize}

Los niveles de prueba se caracterizan por los siguientes atributos:

\begin{itemize}
	\item Objetivos específicos
	\item Base de prueba, referenciada para derivar casos de prueba
	\item Objeto de prueba (es decir, lo que se está probando)
	\item defectos y fallas típicas
\end{itemize}

\subsection{Prueba de sistema}

\textbf {Objetivos de las pruebas del sistema.}\\

Las pruebas del sistema se centran en el comportamiento y las capacidades de un sistema o producto completo, a menudo considerando las tareas de extremo a extremo que el sistema puede realizar y los comportamientos no funcionales que exhibe mientras realiza esas tareas. Los objetivos de las pruebas del sistema incluyen:

\begin{itemize}
	\item Reducción del riesgo.
	\item Verificar si los comportamientos funcionales y no funcionales del sistema son los diseñados y
	especificado
	\item Validar que el sistema está completo y funcionará como se esperaba.
	\item Generar confianza en la calidad del sistema en su conjunto.
	\item Encontrar defectos
	\item Evitar que los defectos escapen a niveles de prueba o producción más altos
\end{itemize}

\textbf {Base de prueba}\\
Los ejemplos de productos de trabajo que se pueden usar como base de prueba para las pruebas del sistema incluyen:

\begin{itemize}
	\item Especificaciones de requisitos del sistema y software (funcionales y no funcionales)
	\item Informes de análisis de riesgos.
	\item Casos de uso
	\item Epics e historias de usuarios
	\item Modelos de comportamiento del sistema.
	\item Diagramas de estado
	\item Sistema y manuales de usuario.
\end{itemize}

\textbf {Objetos de prueba}\\
Los objetos de prueba típicos para las pruebas del sistema incluyen:

\begin{itemize}
	\item Aplicaciones
	\item Sistemas de hardware / software
	\item Sistemas operativos
	\item Sistema bajo prueba (SUT)
\end{itemize}

\subsection{Pruebas Estáticas}

Durante las pruebas estáticas, los productos de trabajo de software se examinan manualmente o con un conjunto de herramientas, pero no se ejecutan. Como consecuencia, las pruebas dinámicas solo pueden aplicarse al código de software. La ejecución dinámica se aplica como una técnica para detectar defectos y para determinar los atributos de calidad del código. 
